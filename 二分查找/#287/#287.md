###知识点
1、 cnt += nums[i] <= mid;          选择加上<=mid的数的写法
2、// 确定二进制下最高位是多少
        int bit_max = 31;
        while (!((n - 1) >> bit_max)) {
            bit_max -= 1;
        }
3、nums[i] & (1 << bit)        判断nums[i]二进制的bit位是否为1，若为1，返回1

###思路
2、记 nums 数组中二进制展开后第 i 位为 1 的数有 x 个，数字 [1,n] 这 n 个数二进制展开后第 i 位为 1 的数有 y 个，那么重复的数第 i 位为 1 当且仅当 x>y。

也就是说如果 target 第 i 位为 1，那么每次替换后只会使 x 不变或增大，如果为 0，只会使 x 不变或减小，始终满足 x>y 时 target 第 i 位为 1，否则为 0，因此我们只要按位还原这个重复的数即可。

3、我们对 nums 数组建图，每个位置 i 连一条 i→nums[i] 的边。由于存在的重复的数字 target，因此 target 这个位置一定有起码两条指向它的边，因此整张图一定存在环，且我们要找到的 target 就是这个环的入口



